leexinc.hrl:49: The pattern <Rest, Line, {'token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:52: The pattern <Rest, Line, {'end_token', T}, Ts> can never match the type <_,_,'error' | 'skip_token',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:54: The pattern <Rest, Line, {'end_token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:59: The pattern <Rest, Line, {'skip_token', Push}, Ts> can never match the type <_,_,'error',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:62: The pattern <_Rest, Line, {'error', S}, _Ts> can never match the type <_,_,'error',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:118: The pattern <Rest, Line, {'token', T, Push}> can never match the type <_,_,'error' | 'skip_token'>
leexinc.hrl:121: The pattern <Rest, Line, {'end_token', T}> can never match the type <_,_,'error' | 'skip_token'>
leexinc.hrl:123: The pattern <Rest, Line, {'end_token', T, Push}> can never match the type <_,_,'error' | 'skip_token'>
leexinc.hrl:128: The pattern <Rest, Line, {'skip_token', Push}> can never match the type <_,_,'error'>
leexinc.hrl:131: The pattern <Rest, Line, {'error', S}> can never match the type <_,_,'error'>
leexinc.hrl:192: The pattern <Rest, Line, {'token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:195: The pattern <Rest, Line, {'end_token', T}, Ts> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:197: The pattern <Rest, Line, {'end_token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:202: The pattern <Rest, Line, {'skip_token', Push}, Ts> can never match the type <_,_,'error',_>
leexinc.hrl:205: The pattern <Rest, Line, {'error', S}, _Ts> can never match the type <_,_,'error',_>
leexinc.hrl:243: The pattern <Rest, Line, {'token', _T, Push}, Error> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:246: The pattern <Rest, Line, {'end_token', _T}, Error> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:248: The pattern <Rest, Line, {'end_token', _T, Push}, Error> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:253: The pattern <Rest, Line, {'skip_token', Push}, Error> can never match the type <_,_,'error',_>
leexinc.hrl:256: The pattern <Rest, Line, {'error', _S}, Error> can never match the type <_,_,'error',_>
leexinc.hrl:260: Function yyrev/2 will never be called
pokemon_pb.erl:47: The pattern <_, 'optional', 'undefined', _, _> can never match the type <1,'required',_,'string',[]>
pokemon_pb.erl:49: The pattern <_, 'repeated', 'undefined', _, _> can never match the type <1,'required',_,'string',[]>
pokemon_pb.erl:51: The pattern <_, 'repeated_packed', 'undefined', _, _> can never match the type <1,'required',_,'string',[]>
pokemon_pb.erl:52: The pattern <_, 'repeated_packed', [], _, _> can never match the type <1,'required',_,'string',[]>
pokemon_pb.erl:57: The pattern <_, 'repeated', [], _, Acc> can never match the type <1,'required',_,'string',[]>
pokemon_pb.erl:60: The pattern <FNum, 'repeated', [Head | Tail], Type, Acc> can never match the type <1,'required',_,'string',[]>
pokemon_pb.erl:63: The pattern <FNum, 'repeated_packed', Data, Type, _> can never match the type <1,'required',_,'string',[]>
pokemon_pb.erl:78: The call pokemon_pb:enum_to_int(Type::'string',Data::atom()) will never return since it differs in the 1st argument from the success typing arguments: ('pikachu','value')
pokemon_pb.erl:80: The pattern <'pikachu', 'value'> can never match the type <'string',atom()>
pokemon_pb.erl:102: The pattern 'true' can never match the type 'false'
pokemon_pb.erl:108: The pattern 'true' can never match the type 'false'
pokemon_pb.erl:118: The pattern 'true' can never match the type 'false'
pokemon_pb.erl:132: The pattern <Binary, 'string'> can never match the type <'-infinity' | 'false' | 'infinity' | 'nan' | 'true' | binary() | [byte()] | number(),'double' | 'int32'>
protobuffs_compile.erl:286: The pattern 'true' can never match the type 'false'
riakclient_pb.erl:51: The pattern <_, 'repeated_packed', 'undefined', _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11,'optional' | 'repeated' | 'required',_,'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpblink' | 'rpbpair' | 'uint32',[binary() | [binary() | [any()]]]>
riakclient_pb.erl:52: The pattern <_, 'repeated_packed', [], _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11,'optional' | 'repeated' | 'required',_,'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpblink' | 'rpbpair' | 'uint32',[binary() | [binary() | [any()]]]>
riakclient_pb.erl:63: The pattern <FNum, 'repeated_packed', Data, Type, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11,'optional' | 'repeated' | 'required',_,'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpblink' | 'rpbpair' | 'uint32',[binary() | [binary() | [any()]]]>
riakclient_pb.erl:78: The call riakclient_pb:enum_to_int(Type::'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpblink' | 'rpbpair' | 'uint32',Data::atom()) will never return since it differs in the 1st argument from the success typing arguments: ('pikachu','value')
riakclient_pb.erl:80: The pattern <'pikachu', 'value'> can never match the type <'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpblink' | 'rpbpair' | 'uint32',atom()>
riakclient_pb.erl:132: The pattern <Binary, 'string'> can never match the type <'-infinity' | 'false' | 'infinity' | 'nan' | 'true' | binary() | [byte()] | number(),'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpblink' | 'rpbpair' | 'uint32'>
